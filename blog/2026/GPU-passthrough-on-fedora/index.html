<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Painless GPU Passthrough Under Fedora | Daniel Gomm </title> <meta name="author" content="Daniel Gomm"> <meta name="description" content="This post covers how to set-up separate boot entries for GPU passthrough on/off under Fedora Linux."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://daniel-gomm.github.io/blog/2026/GPU-passthrough-on-fedora/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Daniel</span> Gomm </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Painless GPU Passthrough Under Fedora</h1> <p class="post-meta"> Created in February 17, 2026 </p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a>   ·   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a>   <a href="/blog/tag/guide"> <i class="fa-solid fa-hashtag fa-sm"></i> guide</a>   <a href="/blog/tag/linux"> <i class="fa-solid fa-hashtag fa-sm"></i> linux</a>   ·   <a href="/blog/category/project"> <i class="fa-solid fa-tag fa-sm"></i> project</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="painless-gpu-passthrough-under-fedora">Painless GPU Passthrough Under Fedora</h1> <blockquote> <p><strong>TL;DR:</strong> If you already know what GPU passthrough is and just want a tool to manage passthrough kernels on Fedora, skip straight to the <a href="#automating-it-with-gpu-passthrough"><code class="language-plaintext highlighter-rouge">gpu-passthrough</code> script</a>. It automates the creation and maintenance of GRUB boot entries for VFIO GPU passthrough, saves your configuration, and handles cleanup after kernel updates. One command, 30 seconds, done.</p> </blockquote> <p>I use Fedora Linux as my daily driver. In my research, my NVIDIA GPU is essential for training and running machine learning models on the host system. But I also use Autodesk Fusion, a cloud-based CAD/CAM/CAE platform that Autodesk only officially supports on Windows and macOS<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. There is no native Linux version, and despite vocal demand from the community<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>, Autodesk has shown no signs of changing course. Wine-based workarounds exist<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>, but they tend to break after updates and aren’t reliable enough for production work. For a while, I got by with Autodesk’s browser-based version of Fusion, but the experience is sluggish and limited compared to the native desktop application.</p> <p>What I really needed was a way to run the full Windows version of Fusion with proper GPU acceleration, without giving up my Linux environment. GPU passthrough with KVM/QEMU makes this possible. It lets you run a Windows virtual machine with direct access to your physical GPU, giving you near-native graphics performance. The tricky part is that Fedora’s frequent kernel updates break the passthrough configuration every time, requiring manual re-setup. To solve this, I wrote <a href="https://github.com/daniel-gomm/qemu-gpu-passthrough-fedora" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">gpu-passthrough</code></a>, a script that automates the entire process. This post explains the technical background, walks through the manual setup, and shows how the script makes ongoing maintenance painless.</p> <p><strong>Disclaimer:</strong> At the time of writing (02/2026), I have tested everything described below on system running Fedora 43 Workstation Edition with an AMD Ryzen 5900HX processor and an NVIDIA RTX 3050 mobile GPU. Use the instructions made here on your own risk.</p> <h2 id="who-this-guide-is-for">Who This Guide Is For</h2> <p>This guide is specifically written for people who need <strong>two modes of operation</strong>. Sometimes you want the GPU available to the Linux host (for ML workloads, gaming, or anything else), and sometimes you want it passed through to a Windows VM (for applications like Fusion, or certain Games that require Windows). The script I describe below manages separate GRUB boot entries that let you choose between these modes at boot time.</p> <p>If you <strong>always</strong> want your GPU passed through to a VM and never need it on the host, you don’t need separate boot entries or this script. In that case, you can simply add your IOMMU and VFIO parameters to <code class="language-plaintext highlighter-rouge">/etc/default/grub</code>, and they will be applied to every kernel automatically, including new ones after updates. The dual-entry approach only makes sense when you need the flexibility to switch.</p> <h2 id="what-youll-need">What You’ll Need</h2> <p>Before diving in, make sure your hardware meets the following requirements.</p> <p>You need <strong>two GPUs</strong>. In my case this is a laptop with an integrated AMD GPU (which drives my Fedora desktop) and a discrete NVIDIA GPU (which I either use for ML work on the host or pass through to the Windows VM). A desktop with two discrete GPUs works just as well.</p> <p>Your <strong>CPU must support hardware virtualization and IOMMU</strong>. On Intel this means VT-x and VT-d; on AMD it means AMD-V and AMD-Vi. Most CPUs from the last decade support these features, but you’ll need to make sure they are enabled in your BIOS/UEFI firmware.</p> <p>Your <strong>motherboard must support IOMMU</strong> with reasonable IOMMU group granularity. This matters because IOMMU groups determine which devices can be passed through together (more on this below). Most modern boards handle this well, though some budget boards may group too many devices together.</p> <p>You’ll also need <strong>QEMU/KVM and virt-manager</strong> installed on your Fedora system. This <a href="https://github.com/br0kenpixel/fedora-qemu-gpu-passthrough" rel="external nofollow noopener" target="_blank">excellent guide by br0kenpixel</a> covers the full installation and VM setup process in detail, so I won’t duplicate that here. This post focuses specifically on the kernel and driver configuration that makes passthrough possible.</p> <h2 id="how-gpu-passthrough-works">How GPU Passthrough Works</h2> <p>To understand what the setup process is doing and why, it helps to know what’s happening at a technical level. GPU passthrough relies on three layers of technology working together.</p> <h3 id="iommu-hardware-level-device-isolation">IOMMU: Hardware-Level Device Isolation</h3> <p>The IOMMU (Input-Output Memory Management Unit) is the hardware foundation for passthrough. It sits between your PCI devices and system memory, translating between device-visible memory addresses and physical addresses. This translation is what makes it safe to give a device directly to a virtual machine without compromising the host’s memory isolation<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup>.</p> <p>The IOMMU organizes PCI devices into <strong>IOMMU groups</strong>, which are sets of devices that share the same address space boundary. A critical rule of passthrough is that you must pass through all devices in a group together. This is why you’ll often need to pass through both a GPU and its companion audio controller (used for HDMI/DisplayPort audio), since they typically share an IOMMU group<sup id="fnref:5:1" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">4</a></sup><sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">5</a></sup>.</p> <h3 id="vfio-binding-devices-for-passthrough">VFIO: Binding Devices for Passthrough</h3> <p>VFIO (Virtual Function I/O) is the Linux kernel framework that makes PCI device passthrough possible. Normally, your GPU is claimed by a driver like <code class="language-plaintext highlighter-rouge">nvidia</code> or <code class="language-plaintext highlighter-rouge">nouveau</code> as soon as the system boots. VFIO provides an alternative driver called <code class="language-plaintext highlighter-rouge">vfio-pci</code> that you can bind to the GPU instead. When <code class="language-plaintext highlighter-rouge">vfio-pci</code> is bound to a device, the host kernel stops using that device entirely and makes it available for assignment to a virtual machine<sup id="fnref:6:1" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">5</a></sup><sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">6</a></sup>.</p> <p>The guest VM then sees the GPU as if it were physically connected, and the guest’s native driver (for example, NVIDIA’s Windows driver) takes over. This is what gives you near-native performance rather than the slow emulated graphics of a standard virtual display adapter.</p> <h3 id="kvmqemu-the-virtualization-stack">KVM/QEMU: The Virtualization Stack</h3> <p>KVM provides hardware-accelerated virtualization in the Linux kernel, and QEMU emulates the rest of the virtual machine’s hardware. Together with libvirt and virt-manager as management frontends, they form the standard open-source virtualization stack on Linux. Once the GPU is bound to VFIO, you simply add it as a PCI host device in your VM configuration, and the guest can drive it directly<sup id="fnref:8" role="doc-noteref"><a href="#fn:8" class="footnote" rel="footnote">7</a></sup>.</p> <h2 id="setting-up-gpu-passthrough-on-fedora">Setting Up GPU Passthrough on Fedora</h2> <p>With the theory covered, here’s what the actual setup process looks like on Fedora. The steps below are based on br0kenpixel’s guide<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">8</a></sup>, which provides more granular detail if you want to follow along manually.</p> <h3 id="step-1-enable-iommu-in-biosuefi">Step 1: Enable IOMMU in BIOS/UEFI</h3> <p>Reboot into your firmware settings and make sure that virtualization support and IOMMU are enabled. On Intel systems, look for “VT-d”; on AMD, look for “AMD-Vi” or “IOMMU”. The exact menu location varies by motherboard manufacturer, but it’s typically under an “Advanced” or “CPU Configuration” section.</p> <h3 id="step-2-identify-your-gpus-pci-ids">Step 2: Identify Your GPU’s PCI IDs</h3> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gpu_passthrough/lspci_vvnn_nvidia-480.webp 480w,/assets/img/blog/gpu_passthrough/lspci_vvnn_nvidia-800.webp 800w,/assets/img/blog/gpu_passthrough/lspci_vvnn_nvidia-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gpu_passthrough/lspci_vvnn_nvidia.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong><em>Figure 1:</em></strong> <em>Result of running <code class="language-plaintext highlighter-rouge">lspci -vvnn | grep NVIDIA</code> and identifying the GPU PCI ID. My system has a only a single PCI group.</em></p> <p>You need the vendor and device ID pairs for your GPU and any companion devices in its IOMMU group. Run <code class="language-plaintext highlighter-rouge">lspci -vvnn</code> and locate your discrete GPU. You’re looking for something like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>01:00.0 3D controller [0302]: NVIDIA Corporation GA107M [GeForce RTX 3050 Mobile] [10de:25a1] (rev a1)
01:00.1 Audio device [0403]: NVIDIA Corporation [10de:2291] (rev a1)
</code></pre></div></div> <p>The IDs in brackets at the end of each line are what you need. In this example, the GPU is <code class="language-plaintext highlighter-rouge">10de:25a1</code> and the audio controller is <code class="language-plaintext highlighter-rouge">10de:2291</code>. Write these down as a comma-separated list (<code class="language-plaintext highlighter-rouge">10de:25a1,10de:2291</code>), since you’ll need them in the next steps.</p> <h3 id="step-3-create-a-passthrough-kernel-boot-entry">Step 3: Create a Passthrough Kernel Boot Entry</h3> <p>This is the step that distinguishes the dual-mode approach from always-on passthrough. Rather than modifying your default kernel (which would blacklist the NVIDIA driver and make the GPU unavailable to the host), you create a <strong>separate boot entry</strong> with passthrough-specific parameters. This way, your normal kernel remains untouched and you can choose at boot time whether you want the GPU on the host or reserved for a VM.</p> <p>Fedora uses <code class="language-plaintext highlighter-rouge">grubby</code> as its GRUB management tool, which lets you clone, modify, and remove individual boot entries. First, clone the current default kernel into a new entry:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">DEFAULT_KERNEL</span><span class="o">=</span><span class="si">$(</span><span class="nb">sudo </span>grubby <span class="nt">--default-kernel</span><span class="si">)</span>
<span class="nv">DEFAULT_INITRD</span><span class="o">=</span><span class="si">$(</span><span class="nb">sudo </span>grubby <span class="nt">--info</span><span class="o">=</span><span class="nv">$DEFAULT_KERNEL</span> | <span class="nb">grep</span> <span class="nt">-oP</span> <span class="s1">'initrd="\K[^"]+'</span> <span class="nt">--max-count</span><span class="o">=</span>1<span class="si">)</span>

<span class="nb">sudo </span>grubby <span class="nt">--grub2</span> <span class="nt">--add-kernel</span><span class="o">=</span><span class="nv">$DEFAULT_KERNEL</span> <span class="se">\</span>
    <span class="nt">--initrd</span><span class="o">=</span><span class="nv">$DEFAULT_INITRD</span> <span class="nt">--copy-default</span> <span class="se">\</span>
    <span class="nt">--title</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">sudo </span>grubby <span class="nt">--default-title</span><span class="si">)</span><span class="s2"> [KVM GPU Passthrough]"</span>
</code></pre></div></div> <h3 id="step-4-set-kernel-parameters-on-the-passthrough-entry">Step 4: Set Kernel Parameters on the Passthrough Entry</h3> <p>The cloned entry needs several parameters. First, blacklist the NVIDIA and Nouveau drivers so they don’t claim the GPU on the host:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>0 <span class="nt">--args</span><span class="o">=</span><span class="s2">"rd.driver.blacklist=nouveau,nvidia,nvidiafb,nvidia-gpu </span><span class="se">\</span><span class="s2">
    modprobe.blacklist=nouveau,nvidia,nvidiafb,nvidia-gpu"</span>
</code></pre></div></div> <p>Then enable IOMMU, disable the EFI framebuffer for the passthrough GPU, load the VFIO driver early, and bind it to your PCI IDs. Use <code class="language-plaintext highlighter-rouge">intel_iommu</code> or <code class="language-plaintext highlighter-rouge">amd_iommu</code> depending on your CPU:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># For AMD CPUs:</span>
<span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>0 <span class="nt">--args</span><span class="o">=</span><span class="s2">"video=efifb:off amd_iommu=on </span><span class="se">\</span><span class="s2">
    rd.driver.pre=vfio-pci kvm.ignore_msrs=1 vfio-pci.ids=YOUR_PCI_IDs"</span>

<span class="c"># For Intel CPUs:</span>
<span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>0 <span class="nt">--args</span><span class="o">=</span><span class="s2">"video=efifb:off intel_iommu=on </span><span class="se">\</span><span class="s2">
    rd.driver.pre=vfio-pci kvm.ignore_msrs=1 vfio-pci.ids=YOUR_PCI_IDs"</span>
</code></pre></div></div> <p>Make sure to replace <code class="language-plaintext highlighter-rouge">YOUR_PCI_IDs</code> with your actual PCI IDs (<code class="language-plaintext highlighter-rouge">10de:25a1,10de:2291</code> in the example).</p> <h3 id="step-5-configure-dracut-first-time-only">Step 5: Configure Dracut (First-Time Only)</h3> <p>On first-time setup, you need to add the VFIO kernel modules to the initial ramdisk so they’re available early in the boot process, before any other driver can claim the GPU:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'add_drivers+=" vfio vfio_iommu_type1 vfio_pci "'</span> | <span class="nb">sudo tee</span> <span class="nt">-a</span> /etc/dracut.conf.d/local.conf
<span class="nb">sudo </span>dracut <span class="nt">-f</span> <span class="nt">--kver</span> <span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>
</code></pre></div></div> <h3 id="step-6-set-the-default-boot-entry">Step 6: Set the Default Boot Entry</h3> <p>Decide whether the passthrough kernel should be your default. If you want to boot into passthrough mode by default, leave the new entry at index 0. If you’d rather keep the normal kernel as default and select passthrough manually at boot time, push the normal kernel back to position 0:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>grubby <span class="nt">--set-default-index</span><span class="o">=</span>1
</code></pre></div></div> <p>After rebooting into the passthrough kernel, your NVIDIA GPU will no longer be visible to the host. You can now assign it to your Windows VM in virt-manager by adding it as a PCI host device.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gpu_passthrough/grub_gpu_passthrough-480.webp 480w,/assets/img/blog/gpu_passthrough/grub_gpu_passthrough-800.webp 800w,/assets/img/blog/gpu_passthrough/grub_gpu_passthrough-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gpu_passthrough/grub_gpu_passthrough.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong><em>Figure 2:</em></strong> <em>Selection between different boot entries in the GRUB boot menu.</em></p> <h2 id="a-note-on-the-gpu-reset-bug">A Note on the GPU Reset Bug</h2> <p>Some AMD and NVIDIA GPUs suffer from what the VFIO community calls a “reset bug.” The symptom is that the GPU refuses to re-initialize after a VM is shut down, meaning you cannot start the VM again without rebooting the entire host. This happens because QEMU fails to correctly reset the card’s internal state when the guest releases it<sup id="fnref:9" role="doc-noteref"><a href="#fn:9" class="footnote" rel="footnote">9</a></sup>.</p> <p>The issue has historically been most common with AMD GPUs, particularly Polaris (RX 400/500 series), Vega, and some Navi cards<sup id="fnref:10" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup><sup id="fnref:11" role="doc-noteref"><a href="#fn:11" class="footnote" rel="footnote">11</a></sup>. For AMD cards, a kernel module called <code class="language-plaintext highlighter-rouge">vendor-reset</code><sup id="fnref:10:1" role="doc-noteref"><a href="#fn:10" class="footnote" rel="footnote">10</a></sup> provides device-specific reset procedures that can work around the bug on many affected models. Some NVIDIA GPUs can also exhibit reset issues, though they tend to be less widespread and often manifest differently, such as long delays during re-initialization rather than a complete failure<sup id="fnref:12" role="doc-noteref"><a href="#fn:12" class="footnote" rel="footnote">12</a></sup>.</p> <p>For the dual-mode workflow described in this guide, the reset bug is less of a concern in practice. Since you are rebooting to switch between passthrough and normal mode anyway, the GPU gets a clean hardware reset every time. The bug primarily affects setups where you want to start and stop VMs repeatedly without rebooting, such as server or headless configurations. Still, it is worth being aware of: if you encounter issues where your VM refuses to start a second time within the same boot, the reset bug is a likely culprit, and rebooting the host will resolve it.</p> <h2 id="maintaining-the-dual-mode-setup">Maintaining the dual-mode setup</h2> <p>If the setup described above were a one-time process, the manual steps would be perfectly fine. The problem is that <strong>Fedora ships kernel updates frequently</strong>, often multiple times per month. Each new kernel version gets its own GRUB boot entry automatically, but your passthrough kernel is a clone of a <em>specific</em> kernel version. When a new kernel arrives, the new default kernel doesn’t have your passthrough parameters, and your old passthrough entry still points at the older kernel. You may also want to clean up stale entries to keep your boot menu manageable.</p> <p>This means that after every kernel update, you need to repeat steps 3 through 6. Clone the new kernel, apply the same parameters, set the default, and delete the old passthrough entry. Doing this once or twice a month gets tedious, and getting it wrong means booting into a state where either your desktop has no GPU or your VM can’t find one.</p> <p>This is a consequence of the dual-mode approach. If you were always passing through the GPU, your parameters in <code class="language-plaintext highlighter-rouge">/etc/default/grub</code> would carry over to new kernels automatically. The flexibility of being able to switch modes comes with the cost of per-kernel configuration, and that’s exactly the cost this script eliminates.</p> <h2 id="automating-it-with-gpu-passthrough">Automating It With <code class="language-plaintext highlighter-rouge">gpu-passthrough</code> </h2> <p>This is why I wrote <a href="https://github.com/daniel-gomm/qemu-gpu-passthrough-fedora" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">gpu-passthrough</code></a>, a script that reduces the entire update process to a single interactive command. It handles both initial setup and repeated updates with the same workflow.</p> <p>On first run, the script asks for your CPU manufacturer (Intel or AMD) and your VFIO PCI IDs. It saves this configuration to <code class="language-plaintext highlighter-rouge">~/.config/gpu-passthrough/</code> so that on subsequent runs, it simply confirms the existing settings rather than asking again. Every time you run it, the script clones whichever kernel is currently the default (which after a system update will be the newest kernel), applies all the necessary parameters, offers to set the default boot entry, and cleans up any previously created passthrough entry. On the very first run, it also handles the dracut configuration automatically.</p> <h3 id="installation">Installation</h3> <p>Install the script with a single command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-fsSL</span> https://raw.githubusercontent.com/daniel-gomm/qemu-gpu-passthrough-fedora/refs/heads/main/install.sh | bash
<span class="nb">source</span> ~/.bashrc
</code></pre></div></div> <h3 id="usage">Usage</h3> <p>After a kernel update (or for first-time setup), just run:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpu-passthrough
</code></pre></div></div> <p>The script walks you through the process interactively, confirming your settings and showing you exactly what it’s about to do before making any changes. The entire flow takes about 30 seconds compared to several minutes of manual <code class="language-plaintext highlighter-rouge">grubby</code> commands and the risk of typos or missed steps.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gpu_passthrough/run_script-480.webp 480w,/assets/img/blog/gpu_passthrough/run_script-800.webp 800w,/assets/img/blog/gpu_passthrough/run_script-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gpu_passthrough/run_script.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong><em>Figure 3:</em></strong> <em>Example of running the <code class="language-plaintext highlighter-rouge">gpu-passthrough</code> script.</em></p> <h2 id="putting-it-all-together">Putting It All Together</h2> <p>My day-to-day workflow with this setup looks like this. Most of the time, I boot into the normal Fedora kernel, where the NVIDIA GPU is available for ML training and inference. When I need Fusion for CAD work, I reboot, select the passthrough kernel from the GRUB menu, and start my Windows VM. The NVIDIA GPU is fully available to Windows with native driver support and near-native performance. When Fedora pushes a kernel update, I run <code class="language-plaintext highlighter-rouge">gpu-passthrough</code>, confirm my settings, and I’m done.</p> <p>For the full VM setup process, including QEMU installation, Windows VM creation, and optional Looking Glass configuration (which lets you view the VM’s display in a window on your Linux host), I highly recommend following br0kenpixel’s guide<sup id="fnref:4:1" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">8</a></sup>. The <code class="language-plaintext highlighter-rouge">gpu-passthrough</code> script is designed to complement that guide by automating the kernel configuration that you’d otherwise need to redo after every update.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blog/gpu_passthrough/virt_manager_gpu-480.webp 480w,/assets/img/blog/gpu_passthrough/virt_manager_gpu-800.webp 800w,/assets/img/blog/gpu_passthrough/virt_manager_gpu-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/blog/gpu_passthrough/virt_manager_gpu.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong><em>Figure 4:</em></strong> <em>GPU listed as PCI host device for VM in virt-manager.</em></p> <p>The script is open source under the MIT License and available on GitHub<sup id="fnref:13" role="doc-noteref"><a href="#fn:13" class="footnote" rel="footnote">13</a></sup>. Contributions and feedback are welcome!</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Autodesk, “Can Fusion be installed on Linux?” <a href="https://www.autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/Is-there-any-way-to-install-Fusion-360-in-Linux.html" rel="external nofollow noopener" target="_blank">https://www.autodesk.com/support/technical/article/caas/sfdcarticles/sfdcarticles/Is-there-any-way-to-install-Fusion-360-in-Linux.html</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Autodesk Community Forums, “Web or native Linux version plans?” <a href="https://forums.autodesk.com/t5/fusion-support-forum/web-or-native-linux-version-plans/td-p/13790425" rel="external nofollow noopener" target="_blank">https://forums.autodesk.com/t5/fusion-support-forum/web-or-native-linux-version-plans/td-p/13790425</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>Steve Zabka, “Autodesk Fusion 360 for Linux” (Wine-based installation scripts). <a href="https://github.com/cryinkfly/Autodesk-Fusion-360-for-Linux" rel="external nofollow noopener" target="_blank">https://github.com/cryinkfly/Autodesk-Fusion-360-for-Linux</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:5" role="doc-endnote"> <p>Arch Wiki, “PCI passthrough via OVMF.” <a href="https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF" rel="external nofollow noopener" target="_blank">https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">↩</a> <a href="#fnref:5:1" class="reversefootnote" role="doc-backlink">↩<sup>2</sup></a></p> </li> <li id="fn:6" role="doc-endnote"> <p>Gentoo Wiki, “GPU passthrough with virt-manager, QEMU, and KVM.” <a href="https://wiki.gentoo.org/wiki/GPU_passthrough_with_virt-manager,_QEMU,_and_KVM" rel="external nofollow noopener" target="_blank">https://wiki.gentoo.org/wiki/GPU_passthrough_with_virt-manager,_QEMU,_and_KVM</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">↩</a> <a href="#fnref:6:1" class="reversefootnote" role="doc-backlink">↩<sup>2</sup></a></p> </li> <li id="fn:7" role="doc-endnote"> <p>Ubuntu Server Documentation, “GPU virtualisation with QEMU/KVM.” <a href="https://documentation.ubuntu.com/server/how-to/graphics/gpu-virtualization-with-qemu-kvm/" rel="external nofollow noopener" target="_blank">https://documentation.ubuntu.com/server/how-to/graphics/gpu-virtualization-with-qemu-kvm/</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:8" role="doc-endnote"> <p>Cloudrift, “Host Setup for QEMU KVM GPU Passthrough with VFIO on Linux.” <a href="https://www.cloudrift.ai/blog/host-setup-for-qemu-kvm-gpu-passthrough-with-vfio-on-linux" rel="external nofollow noopener" target="_blank">https://www.cloudrift.ai/blog/host-setup-for-qemu-kvm-gpu-passthrough-with-vfio-on-linux</a> <a href="#fnref:8" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:4" role="doc-endnote"> <p>br0kenpixel, “Fedora QEMU GPU Passthrough Guide.” <a href="https://github.com/br0kenpixel/fedora-qemu-gpu-passthrough" rel="external nofollow noopener" target="_blank">https://github.com/br0kenpixel/fedora-qemu-gpu-passthrough</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a> <a href="#fnref:4:1" class="reversefootnote" role="doc-backlink">↩<sup>2</sup></a></p> </li> <li id="fn:9" role="doc-endnote"> <p>jkhsjdhjs, “A collection of links regarding GPU passthrough.” <a href="https://github.com/jkhsjdhjs/gpu-passthrough" rel="external nofollow noopener" target="_blank">https://github.com/jkhsjdhjs/gpu-passthrough</a> <a href="#fnref:9" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:10" role="doc-endnote"> <p>Nicholas Sherlock, “Working around the AMD GPU Reset bug on Proxmox using vendor-reset.” <a href="https://www.nicksherlock.com/2020/11/working-around-the-amd-gpu-reset-bug-on-proxmox/" rel="external nofollow noopener" target="_blank">https://www.nicksherlock.com/2020/11/working-around-the-amd-gpu-reset-bug-on-proxmox/</a> <a href="#fnref:10" class="reversefootnote" role="doc-backlink">↩</a> <a href="#fnref:10:1" class="reversefootnote" role="doc-backlink">↩<sup>2</sup></a></p> </li> <li id="fn:11" role="doc-endnote"> <p>Proxmox Forum, “AMD GPU inaccessible after VM Poweroff.” <a href="https://forum.proxmox.com/threads/amd-gpu-inaccessible-after-vm-poweroff-unable-to-change-power-state-from-d3cold-to-d0-device-inaccessible.130975/" rel="external nofollow noopener" target="_blank">https://forum.proxmox.com/threads/amd-gpu-inaccessible-after-vm-poweroff-unable-to-change-power-state-from-d3cold-to-d0-device-inaccessible.130975/</a> <a href="#fnref:11" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:12" role="doc-endnote"> <p>Proxmox Forum, “3 Minute Delay Starting VM with GPU Passthrough (vfio-pci reset issue).” <a href="https://forum.proxmox.com/threads/3-minute-delay-starting-vm-with-gpu-passthrough-vfio-pci-reset-issue.174809/" rel="external nofollow noopener" target="_blank">https://forum.proxmox.com/threads/3-minute-delay-starting-vm-with-gpu-passthrough-vfio-pci-reset-issue.174809/</a> <a href="#fnref:12" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:13" role="doc-endnote"> <p>Daniel Gomm, “qemu-gpu-passthrough-fedora.” <a href="https://github.com/daniel-gomm/qemu-gpu-passthrough-fedora" rel="external nofollow noopener" target="_blank">https://github.com/daniel-gomm/qemu-gpu-passthrough-fedora</a> <a href="#fnref:13" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Have-you-Queries-Already-Seen-the-Data/">Have your Queries Already Seen the Data? Data-Privilege in Tabular Benchmarks</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/openbatch/">A Practical Guide to the OpenAI Batch API with Python and openbatch</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Table-Serialization-Kitchen/">Table Serialization Kitchen - A Recipe for Better LLM Performance on Tabular Data</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Daniel Gomm. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme and <a href="https://www.nordtheme.com" target="_blank" rel="external nofollow noopener">Nord colors</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: February 17, 2026. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-publications",title:"publications",description:"publications by categories in reversed chronological order.",section:"Navigation",handler:()=>{window.location.href="/publications/"}},{id:"nav-projects",title:"projects",description:"A growing collection of my projects. [Work In Progress]",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"repositories",description:"Overview of repositories for interesting projects that I&#39;ve worked on.",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-cv",title:"cv",description:"Feel free to explore my professional and academic journey.",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-painless-gpu-passthrough-under-fedora",title:"Painless GPU Passthrough Under Fedora",description:"This post covers how to set-up separate boot entries for GPU passthrough on/off under Fedora Linux.",section:"Posts",handler:()=>{window.location.href="/blog/2026/GPU-passthrough-on-fedora/"}},{id:"post-have-your-queries-already-seen-the-data-data-privilege-in-tabular-benchmarks",title:"Have your Queries Already Seen the Data? Data-Privilege in Tabular Benchmarks",description:"Investigation into what information is leaked into queries in popular tabular benchmarks.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Have-you-Queries-Already-Seen-the-Data/"}},{id:"post-a-practical-guide-to-the-openai-batch-api-with-python-and-openbatch",title:"A Practical Guide to the OpenAI Batch API with Python and openbatch",description:"This post introduces `openbatch`, a Python library designed to make the powerful but often cumbersome OpenAI Batch API as convenient and easy to use as standard sequential calls.",section:"Posts",handler:()=>{window.location.href="/blog/2025/openbatch/"}},{id:"post-table-serialization-kitchen-a-recipe-for-better-llm-performance-on-tabular-data",title:"Table Serialization Kitchen - A Recipe for Better LLM Performance on Tabular Data...",description:"This blog post explores table serializations and their impact on downstream tasks using the Table Serialization Kitchen.",section:"Posts",handler:()=>{window.location.href="/blog/2025/Table-Serialization-Kitchen/"}},{id:"news-started-scientific-traineeship-at-the-joint-research-center-of-the-european-commission",title:"Started scientific traineeship at the Joint Research Center of the European Commission",description:"",section:"News",handler:()=>{window.location.href="/news/2024_04_01_joined_ecat/"}},{id:"news-joined-centrum-wiskunde-amp-informatica-as-phd-student",title:"Joined Centrum Wiskunde &amp; Informatica as PhD student",description:"",section:"News",handler:()=>{window.location.href="/news/2024_10_01_joined_cwi/"}},{id:"news-started-the-amsterdam-lunch-on-table-alot-reading-group",title:"Started the Amsterdam Lunch on Table (ALOT) reading group",description:"",section:"News",handler:()=>{window.location.href="/news/2025_04_01_established_reading_group/"}},{id:"news-spotlight-presentation-at-the-ai-for-tabular-data-workshop-eurips-2025",title:"Spotlight Presentation at the AI for Tabular Data Workshop@EurIPS 2025",description:"",section:"News",handler:()=>{window.location.href="/news/2025_12_06_presented_at_eurips/"}},{id:"news-presented-my-work-at-the-trl-seminar",title:"Presented my work at the TRL-Seminar",description:"",section:"News",handler:()=>{window.location.href="/news/2026_01_23_presented_trl_seminar/"}},{id:"projects-pytei",title:"PyTEI",description:"A lightweight python client package for Huggingface Text Embedding Inference",section:"Projects",handler:()=>{window.location.href="/projects/PyTEI/"}},{id:"projects-table-serializer-kitchen",title:"Table Serializer Kitchen",description:"A flexible, extensible, and easy-to-use package for serializing tabular data for the use with LLMs.",section:"Projects",handler:()=>{window.location.href="/projects/table-serializer-kitchen/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%64%61%6E%69%65%6C.%67%6F%6D%6D[%61%74]%63%77%69.%6E%6C","_blank")}},{id:"socials-orcid",title:"ORCID",section:"Socials",handler:()=>{window.open("https://orcid.org/0009-0007-5489-992X","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=JX0iKVMAAAAJ","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/daniel-gomm","_blank")}},{id:"socials-linkedin",title:"LinkedIn",section:"Socials",handler:()=>{window.open("https://www.linkedin.com/in/daniel-gomm","_blank")}},{id:"socials-bluesky",title:"Bluesky",section:"Socials",handler:()=>{window.open("https://bsky.app/profile/https://bsky.app/profile/daniel-gomm.bsky.social# your bluesky URL","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>